\subsection{Optimizations for Leiden algorithm}
\label{sec:leiden}

We extend our optimizations for the Louvain algorithm \cite{sahu2023gvelouvain}, to the Leiden algorithm. In particular, we employ an \textit{asynchronous} implementation of the Leiden algorithm, where threads operate independently on distinct sections of the graph. This facilitates quicker convergence but introduces variability into the final result \cite{com-shi21}. To perform computations efficiently, we pre-allocate a dedicated hashtable per thread. These hashtables serve two primary purposes: they keep track of the delta-modularity associated with moving to each community connected to a vertex during the local-moving/refinement phases, and they record the total edge weight between super-vertices in the aggregation phase of the algorithm \cite{sahu2023gvelouvain}.

Our optimizations encompass several strategies, including utilizing OpenMP's \textit{dynamic} loop scheduling, capping the number of iterations per pass at $20$, employing a tolerance drop rate of $10$ (threshold scaling), initiating with a tolerance of $0.01$, using an aggregation tolerance of $0.8$ to avoid performing aggregations of minimal utility, implementing flag-based vertex pruning (instead of a queue-based one \cite{nguyenleiden}), utilizing parallel prefix sum, and using preallocated Compressed Sparse Row (CSR) data structures for identifying community vertices and storing the super-vertex graph during aggregation. Additionally, we employ fast collision-free per-thread hashtables, well separated in their memory addresses \cite{sahu2023gvelouvain}.

We attempt two approaches of the Leiden algorithm. One uses a \textit{greedy refinement phase} where vertices greedily optimize for delta-modularity (within their community bounds), while the other uses a \textit{random-greedy refinement phase} (using a fast \textit{xorshift32} random number generator), where the likelihood of selection of a community to move to (by a vertex) is proportional to its delta-modularity (as originally proposed by Traag et al. \cite{com-traag19}). Our experiments show the \textit{greedy approach} performs the best on average, both in terms of runtime and modularity. We also try medium and heavy variants for both approaches, which disables threshold scaling and aggregation tolerance (including threshold scaling) respectively, However, we do not find them to perform well overall.\ignore{On \textit{europe\_osm} graph, our parallel Greedy-Leiden (which we from here on refer to simply as Leiden) runs $3\times$ faster than Nguyen \cite{nguyenleiden}.}

\ignore{We fixed a bug that caused the Leiden algorithm to fail in finding communities on road networks and kmer graphs. The issue was forgetting to reset the affected vertices flags before running the refinement phase.}




\subsection{Our optimized Leiden implementation}

We now explain the implementation of GVE-Leiden in Algorithms \ref{alg:leiden}, \ref{alg:leidenlm}, \ref{alg:leidenre}, and \ref{alg:leidenag}. A flow diagram illustrating the first pass of GVE-Leiden is shown in Figure \ref{fig:leiden-pass} \su{TODO}.


\subsubsection{Main step of GVE-Leiden}

The main step of GVE-Leiden (\texttt{leiden()} function) is outlined in Algorithm \ref{alg:leiden}. It encompasses initialization, the local-moving phase, the refinement phase, and the aggregation phase. Here, the \texttt{leiden()} function takes the input graph $G$, and returns the community membership $C$ for each vertex. In line \ref{alg:leiden--initialization}, we first initialize the community membership $C$ of each vertex in $G$, and perform passes of the Leiden algorithm, limited to $MAX\_PASSES$ (lines \ref{alg:leiden--passes-begin}-\ref{alg:leiden--passes-end}). In each pass, we initialize the total edge weight of each vertex $K'$, the total edge weight of each community $\Sigma'$, and the community membership $C'$ of each vertex in the current graph $G'$ (line \ref{alg:leiden--reset-weights}).

Next, in line \ref{alg:leiden--local-move}, we perform the local-moving phase by calling \texttt{leidenMove()} (Algorithm \ref{alg:leidenlm}), which optimizes community assignments. Next, we initialize the \textit{community bound} of each vertex (for the refinement phase) as the community membership of each vertex obtained in the local-moving phase, and reset the community membership of each vertex, and the total weight of each community as singleton vertices in line X. Next, in line X, perform the refinement phase by invoking \texttt{leidenRefine()} (Algorithm \ref{alg:leidenre}), which optimizes the community assignment of each vertex within its community bound. If the local-moving phase or the refinement phase converged in a single iteration, global convergence is implied and we terminate the passes (line \ref{alg:leiden--globally-converged}). Further, if the drop is community count $|\Gamma|$ is too small, we have reached the point of diminishing returns, and thus stop at the current pass (line \ref{alg:leiden--aggregation-tolerance}).

In case convergence has not been achieved, we renumber communities (line \ref{alg:leiden--renumber}), update top-level community memberships $C$ with dendrogram lookup (line \ref{alg:leiden--lookup}), perform the aggregation phase by calling \texttt{leidenAggregate()} (Algorithm \ref{alg:leidenag}), and scale the convergence threshold for subsequent passes, i.e., perform threshold scaling (line \ref{alg:leiden--threshold-scaling}). The next pass continues in line \ref{alg:leiden--passes-begin}. At the end of all passes, we perform a final update of the top-level community memberships $C$ with dendrogram lookup (line \ref{alg:leiden--lookup-last}), and return the top-level community membership $C$ of each vertex in $G$.

\input{src/alg-leiden}
\input{src/alg-leidenlm}
\input{src/alg-leidenre}
\input{src/alg-leidenag}
\input{src/alg-disconnected}


\subsubsection{Local-moving phase of GVE-Leiden}

The pseuodocode for the local-moving phase of GVE-Leiden is presented in Algorithm \ref{alg:leidenlm}, which iteratively moves vertices between communities to maximize modularity. Here, the \texttt{leidenMove()} function takes the current graph $G'$, community membership $C'$, total edge weight of each vertex $K'$, and total edge weight of each community $\Sigma'$ as input, and returns the number of iterations performed $l_i$.

Lines \ref{alg:leidenlm--iterations-begin}-\ref{alg:leidenlm--iterations-end} represent the main loop of the local-moving phase. In line \ref{alg:leidenlm--reset-affected}, we first mark all vertices as unprocessed. Then, in line \ref{alg:leidenlm--init-deltaq}, we first initialize the total delta-modularity per iteration $\Delta Q$. Next, in lines \ref{alg:leidenlm--loop-vertices-end}-\ref{alg:leidenlm--loop-vertices-end}, we iterate over unprocessed vertices in parallel. For each vertex $i$, we mark $i$ as processed - vertex pruning (line \ref{alg:leidenlm--prune}), scan communities connected to $i$ - excluding self (line \ref{alg:leidenlm--scan}), determine the best community $c*$ to move $i$ to (line \ref{alg:leidenlm--best-community-begin}), calculate the delta-modularity of moving $i$ to $c*$ (line \ref{alg:leidenlm--best-community-end}), and update the community membership  (lines \ref{alg:leidenlm--perform-move-begin}-\ref{alg:leidenlm--perform-move-end}) of $i$, and mark its neighbors as unprocessed (line \ref{alg:leidenlm--remark}) if a better community was found. In line \ref{alg:leidenlm--locally-converged}, we check if the local-moving phase has converged (locally). If so, we break out of the loop (or if $MAX\_ITERATIONS$ is reached). At the end, in line \ref{alg:leidenlm--return}, we return the number of iterations performed $l_i$.


\subsubsection{Refinement phase of GVE-Leiden}

The pseuodocode for the refinement phase of GVE-Leiden is presented in Algorithm \ref{alg:leidenlm}. This is very similar to the local-moving phase, but unlike the local-moving phase, the community membership of each vertex obtained from the local-moving phase is used as a \textit{community bound}, and each vertex must choose to join the community of another vertex within its community bound. Similar to the local-moving phase however, vertices iteratively move between communities to maximize modularity. At the start of the refinement phase, the community membership of each vertex is reset, such that each vertex is its own community. Here, in the refinement phase, the \texttt{leidenRefine()} function takes the current graph $G'$, the community bound of each vertex $C'_B$, the initial community membership $C'$ of each vertex, the total edge weight of each vertex $K'$, the initial total edge weight of each community $\Sigma'$ as input, and the current per iteration tolerance $\tau$, and returns the number of iterations performed $l_j$.

Lines \ref{alg:leidenre--iterations-begin}-\ref{alg:leidenre--iterations-end} represent the main loop of the refinement phase. In line \ref{alg:leidenre--reset-affected}, we first mark all vertices as unprocessed. Then, in line \ref{alg:leidenre--init-deltaq}, we initialize the total delta-modularity per iteration $\Delta Q$. Next, in lines \ref{alg:leidenre--loop-vertices-end}-\ref{alg:leidenre--loop-vertices-end}, we iterate over unprocessed vertices in parallel. For each vertex $i$, we mark $i$ as processed - vertex pruning (line \ref{alg:leidenre--prune}), scan communities connected to $i$ within the \textit{same community bound} - excluding self (line \ref{alg:leidenre--scan}), determine the best community $c*$ to move $i$ to (line \ref{alg:leidenre--best-community-begin}), calculate the delta-modularity of moving $i$ to $c*$ (line \ref{alg:leidenre--best-community-end}), and update the community membership  (lines \ref{alg:leidenre--perform-move-begin}-\ref{alg:leidenre--perform-move-end}) of $i$, and mark its neighbors as unprocessed (line \ref{alg:leidenre--remark}) if a better community was found. In line \ref{alg:leidenre--locally-converged}, we check if the local-moving phase has converged (locally). If so, we break out of the loop (or if $MAX\_ITERATIONS$ is reached). At the end, in line \ref{alg:leidenre--return}, we return the number of iterations performed $l_j$.


\subsubsection{Aggregation phase of GVE-Leiden}

Finally, the psuedocode for the aggregation phase is shown in Algorithm \ref{alg:leidenag}, which aggregates communities into super-vertices. Here, the \texttt{leidenAggregate()} function takes the current graph $G'$ and the community membership $C'$ as input, and returns the super-vertex graph $G''$.

In lines \ref{alg:leidenag--coff-begin}-\ref{alg:leidenag--coff-end}, the offsets array for the community vertices CSR $G'_{C'}.offsets$ is obtained by first counting the number of vertices belonging to each community using \texttt{countCommunity} \texttt{Vertices()}, and then performing exclusive scan on the array. In lines \ref{alg:leidenag--comv-begin}-\ref{alg:leidenag--comv-end}, we iterate over all vertices in parallel and atomically populate vertices belonging to each community into the community graph CSR $G'_{C'}$. Next, we obtain the offsets array for the super-vertex graph CSR by over-estimating the degree of each super-vertex, i.e., by obtaining the total degree of each community with \texttt{communityTotalDegree()}, and then performing exclusive scan on the array (lines \ref{alg:leidenag--yoff-begin}-\ref{alg:leidenag--yoff-end}). This causes the super-vertex graph CSR to be holey, i.e., with gaps in between the edges and weights array of each super-vertex in the CSR. Then, in lines \ref{alg:leidenag--y-begin}-\ref{alg:leidenag--y-end}, we iterate over all communities $c \in [0, |\Gamma|)$ in parallel, and add all communities $d$ (with associated edge weight $w$) linked to each vertex $i$ belonging to community $c$ (with \texttt{scanCommunities()} defined in Algorithm \ref{alg:leidenlm}) to the per-thread hashtable $H_t$. Once $H_t$ is populated with all communities (and associated weights) linked to community $c$, we add them as edges to super-vertex $c$ into the super-vertex graph $G''$ atomically. At the end, in line \ref{alg:leidenag--return}, we return the super-vertex graph $G''$.

\input{src/fig-leiden-pass}




\subsection{Finding disconnected communities}

We now present our algorithm for finding disconnected communities, given the original graph, and the community membership of each vertex in the graph. Our main idea is to, first, find the size of each community, pick a vertex from each community, traverse from that vertex within the community (avoid going to any other adjacent community), and finally, if all vertices within the community could not be reached, we know its disconnected. We attempt four different approaches, based of whether we use parallel DFS or BFS, and whether we use per-thread or shared \textit{visited} flags (if it is shared, each thread should scan all vertices, but only process that community which belongs to it - this is determined by community id). Our observations indicate that using a parallel BFS traversal with a shared flag vector is the fastest. This is not a heuristic algorithm, so all approaches return the same result. We show the pseudocode of this approach in Algorithm \ref{alg:disconnected}.




The pseudocode for finding disconnected communities in parallel is presented in Algorithm \ref{alg:disconnected}. The \texttt{disconnectedCommunities()} function takes the input graph $G$ and the community membership $C$ as input, and it returns the disconnected flag $D$ for each community.

First, in line X, the disconnected community flag $D$, and the visited vertices flags $vis$ are initialized. In line X, the size of each community $S$ is obtained in parallel using the \texttt{communitySizes()}.

Next, with each thread (in parallel), and for each vertex $i$ in the graph $G$, we perform the main computation of the algorithm (lines X-Y). In line X, we obtain the community membership of $i$ ($c$), and initialize the number of vertices reached from $i$ to $0$. If the community $c$ is empty or does not belong to the work-list of the current thread, the current thread simply skips to the next iteration.

Otherwise, we perform performs BFS from vertex $i$ to explore the vertices belonging to the same community, using lambda functions $f_{if}$ to conditionally perform BFS to vertex $j$ if it belongs to the same community, and $f_{do}$ to update the count of $reached$ vertices, after each vertex is visited with BFS. Next, in line X, the number of vertices $reached$ during BFS is compared to the community size, and if it is less, the community is marked as disconnected by setting $D[c]$ to 1. Finally, the size of the community $S[c]$ is updated to 0, indicating that the community has been processed. Note that the work-list $work_t$ of each thread, with id $t$, is defined as a set which contains $[t\chi,\ t(\chi+1))\ \cup\ [T\chi + t\chi,\ T\chi + t(\chi+1))\ \cup\ \ldots$, where $\chi$ is the chunk size, and $T$ is the number of threads. We use a chunk size of $\chi = 1024$.
