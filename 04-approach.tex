\subsection{Optimizations for Leiden algorithm}
\label{sec:leiden}

We extend optimization techniques, originally designed for the Louvain method \cite{sahu2023gvelouvain}, to the Leiden algorithm. Specifically, we implement an \textit{asynchronous} version of the Leiden algorithm, allowing threads to operate independently on distinct sections of the graph. While this approach promotes faster convergence, it also introduces variability into the final result \cite{com-shi21}. To ensure efficient computations, we allocate a dedicated hashtable per thread. These hashtables serve two main purposes: they keep track of the delta-modularity associated with moving to each community connected to a vertex during the local-moving/refinement phases, and they record the total edge weight between super-vertices in the aggregation phase of the algorithm \cite{sahu2023gvelouvain}.

Our optimizations include using preallocated Compressed Sparse Row (CSR) data structures for identifying community vertices ($G'_{C'}$ in Algorithm \ref{alg:leidenag}) and storing the super-vertex graph ($G''$ in Algorithm \ref{alg:leidenag}) during aggregation, utilizing parallel prefix sum (lines \ref{alg:leidenag--coff-begin}-\ref{alg:leidenag--coff-end}, \ref{alg:leidenag--yoff-end} in Algorithm \ref{alg:leidenag}), employing fast collision-free per-thread hashtables that are well separated in their memory addresses ($H_t$ in Algorithms \ref{alg:leidenlm}, \ref{alg:leidenre}, and \ref{alg:leidenag}), and using an aggregation tolerance of $0.8$ to avoid performing aggregations of minimal utility (line \ref{alg:leiden--aggregation-tolerance} in Algorithm \ref{alg:leidenag}). Additionally, we implement flag-based vertex pruning (lines \ref{alg:leidenlm--reset-affected}, \ref{alg:leidenlm--prune}, \ref{alg:leidenlm--remark} in Algorithm \ref{alg:leidenlm}) --- instead of a queue-based one \cite{nguyenleiden}, utilize OpenMP's \textit{dynamic} loop scheduling, cap the number of iterations per pass at $20$ (line \ref{alg:leidenlm--iterations-begin} in Algorithm \ref{alg:leidenlm}), employ a tolerance drop rate of $10$ (line \ref{alg:leiden--threshold-scaling} in Algorithm \ref{alg:leiden}) --- threshold scaling optimization, and initiate with a tolerance of $0.01$ \cite{sahu2023gvelouvain}.

We attempt two approaches of the Leiden algorithm. One uses a \textit{greedy refinement phase} where vertices greedily optimize for delta-modularity (within their community bounds), while the other uses a \textit{randomized refinement phase} (using fast \textit{xorshift32} random number generators), where the likelihood of selection of a community to move to (by a vertex) is proportional to its delta-modularity, as originally proposed \cite{com-traag19}. Our results, shown in Figures \ref{fig:leidenopt-runtime} and \ref{fig:leidenopt-modularity}, indicate the \textit{greedy approach} performs the best on average, both in terms of runtime and modularity. We also try medium and heavy variants for both approaches, which disables threshold scaling and aggregation tolerance (including threshold scaling) respectively, However, we do not find them to perform well overall.\ignore{On \textit{europe\_osm} graph, our parallel Greedy-Leiden (which we from here on refer to simply as Leiden) runs $3\times$ faster than Nguyen \cite{nguyenleiden}.}

\ignore{\subsection{Community labels of super-vertices}}

We also attempt two different variations of Parallel Leiden algorithm, one where the community labels of super-vertices (upon aggregation) is based on the local-moving phase (\textit{move-based}), and the other where the community labels of super-vertices is based on the refinement phase (\textit{refine-based}). Our observations indicate that both approaches have roughly the same runtime and modularity on average, as indicated by Figures \ref{fig:leidenreopt-runtime} and \ref{fig:leidenreopt-modularity}. Accordingly, we stick to the move-based approach, which is the one recommended by Traag et al. \cite{com-traag19}. However, refine-based approach may be more suitable for the design of dynamic Leiden algorithm (for dynamic graphs).

\ignore{We fixed a bug that caused the Leiden algorithm to fail in finding communities on road networks and kmer graphs. The issue was forgetting to reset the affected vertices flags before running the refinement phase.}

\input{src/fig-leidenopt-runtime}
\input{src/fig-leidenopt-modularity}
\input{src/fig-leidenreopt-runtime}
\input{src/fig-leidenreopt-modularity}
\input{src/fig-leiden-pass}




\subsection{Our optimized Leiden implementation}

We now explain the implementation of GVE-Leiden in Algorithms \ref{alg:leiden}, \ref{alg:leidenlm}, \ref{alg:leidenre}, and \ref{alg:leidenag}. Our intention is to integrate GVE-Leiden into a forthcoming command-line graph processing tool named "GVE", which simply stands for Graph(Vertices, Edges), hence the name. GVE-Leiden operates with a time complexity of $O(KM)$, where $K$ is the total number of iterations performed, and a space complexity of $O(TN + M)$, where $T$ represents the number of threads, and $TN$ accounts for the collision-free hash tables $H_t$ used per thread. Figure \ref{fig:leiden-pass} illustrates the first pass of GVE-Leiden.


\subsubsection{Main step of GVE-Leiden}

The main step of GVE-Leiden (\texttt{leiden()} function) is outlined in Algorithm \ref{alg:leiden}. It encompasses initialization, the local-moving phase, the refinement phase, and the aggregation phase. Here, the \texttt{leiden()} function accepts the input graph $G$, and returns the community membership $C$ of each vertex. In line \ref{alg:leiden--initialization}, we first initialize the community membership $C$ for each vertex in $G$, and perform passes of the Leiden algorithm, limited to $MAX\_PASSES$ (lines \ref{alg:leiden--passes-begin}-\ref{alg:leiden--passes-end}). During each pass, we initialize the total edge weight of each vertex $K'$, the total edge weight of each community $\Sigma'$, and the community membership $C'$ of each vertex in the current graph $G'$ (line \ref{alg:leiden--reset-weights}).

Subsequently, in line \ref{alg:leiden--local-move}, we perform the local-moving phase by invoking \texttt{leidenMove()}\ignore{(Algorithm \ref{alg:leidenlm})}, which optimizes community assignments. Following this, we set the \textit{community bound} of each vertex (for the refinement phase) as the community membership of each vertex just obtained, and reset the membership of each vertex, and the total weight of each community as singleton vertices in line \ref{alg:leiden--reset-again}. In line \ref{alg:leiden--refine}, the refinement phase is carried out by invoking \texttt{leidenRefine()}\ignore{(Algorithm \ref{alg:leidenre})}, which optimizes the community assignment of each vertex within its community bound. If the local-moving phase converges in a single iteration, global convergence is implied and we terminate the passes (line \ref{alg:leiden--globally-converged}). Further, if the drop in the number of communities $|\Gamma|$ is marginal, we halt the algorithm at the current pass (line \ref{alg:leiden--aggregation-tolerance}).

If convergence has not been achieved, we proceed to renumber communities (line \ref{alg:leiden--renumber}), update top-level community memberships $C$ with dendrogram lookup (line \ref{alg:leiden--lookup}), perform the aggregation phase by calling \texttt{leidenAggregate()}\ignore{(Algorithm \ref{alg:leidenag})}, and adjust the convergence threshold for subsequent passes, i.e., perform threshold scaling (line \ref{alg:leiden--threshold-scaling}). The next pass commences in line \ref{alg:leiden--passes-begin}. At the end of all passes, we perform a final update of the top-level community memberships $C$ with dendrogram lookup (line \ref{alg:leiden--lookup-last}), and return the top-level community membership $C$ of each vertex in $G$.

\input{src/alg-leiden}
\input{src/alg-leidenlm}
\input{src/alg-leidenre}
\input{src/alg-leidenag}


\subsubsection{Local-moving phase of GVE-Leiden}

The pseuodocode for the local-moving phase of GVE-Leiden is shown in Algorithm \ref{alg:leidenlm}, which iteratively moves vertices between communities to maximize modularity. Here, the \texttt{leidenMove()} function takes the current graph $G'$, community membership $C'$, total edge weight of each vertex $K'$ and each community $\Sigma'$, the iteration tolerance $\tau$ as input, and returns the number of iterations performed $l_i$.

Lines \ref{alg:leidenlm--iterations-begin}-\ref{alg:leidenlm--iterations-end} represent the main loop of the local-moving phase. In line \ref{alg:leidenlm--reset-affected}, we first mark all vertices as unprocessed. Then, in line \ref{alg:leidenlm--init-deltaq}, we initialize the total delta-modularity per iteration $\Delta Q$. Next, in lines \ref{alg:leidenlm--loop-vertices-begin}-\ref{alg:leidenlm--loop-vertices-end}, we iterate over unprocessed vertices in parallel. For each unprocessed vertex $i$, we mark $i$ as processed - vertex pruning (line \ref{alg:leidenlm--prune}), scan communities connected to $i$ - excluding self (line \ref{alg:leidenlm--scan}), determine the best community $c*$ to move $i$ to (line \ref{alg:leidenlm--best-community-begin}), and calculate the delta-modularity of moving $i$ to $c*$ (line \ref{alg:leidenlm--best-community-end}). We then update the community membership of $i$ (lines \ref{alg:leidenlm--perform-move-begin}-\ref{alg:leidenlm--perform-move-end}) and mark its neighbors as unprocessed (line \ref{alg:leidenlm--remark}) if a better community was found. In line \ref{alg:leidenlm--locally-converged}, we check if the local-moving phase has converged. If so, we break out of the loop (or if $MAX\_ITERATIONS$ is reached). At the end, in line \ref{alg:leidenlm--return}, we return the number of iterations performed $l_i$.


\subsubsection{Refinement phase of GVE-Leiden}

The pseuodocode for the refinement phase of GVE-Leiden is presented in Algorithm \ref{alg:leidenre}. This is similar to the local-moving phase, but utilizes the obtained community membership of each vertex as a \textit{community bound}, where each vertex must choose to join the community of another vertex within its community bound.\ignore{Similar to the local-moving phase however, vertices iteratively move between communities to maximize modularity.} At the start of the refinement phase, the community membership of each vertex is reset, such that each vertex belongs to its own community. Here, the \texttt{leidenRefine()} function takes the current graph $G'$, the community bound of each vertex $C'_B$, the initial community membership $C'$ of each vertex, the total edge weight of each vertex $K'$, the initial total edge weight of each community $\Sigma'$, and the current per iteration tolerance $\tau$ as input, and returns the number of iterations performed $l_j$.

Lines \ref{alg:leidenre--loop-vertices-begin}-\ref{alg:leidenre--loop-vertices-end} represent the core of the refinement phase. In the refinement phase, we perform, what is called the constrained merge procedure \cite{com-traag19}. The idea here is to allow vertices, within each community bound, to form sub-communities by only allowing isolated vertices (i.e., vertices belonging to their own community) to change their community membership. This procedure splits any internally-disconnected communities identified during the local-moving phase, and prevents the formation of any new disconnected communities. Here, for each isolated vertex $i$ (line \ref{alg:leidenre--check-isolated}), we scan communities connected to $i$ within the \textit{same community bound} - excluding self (line \ref{alg:leidenre--scan}), evaluate the best community $c*$ to move $i$ to (line \ref{alg:leidenre--best-community-begin}), and compute the delta-modularity of moving $i$ to $c*$ (line \ref{alg:leidenre--best-community-end}). If a better community was found, we attempt to update the community membership of $i$ if it is still isolated (lines \ref{alg:leidenre--perform-move-begin}-\ref{alg:leidenre--perform-move-end}).


\subsubsection{Aggregation phase of GVE-Leiden}

Finally, we show the psuedocode for the aggregation phase in Algorithm \ref{alg:leidenag}, where communities are aggregated into super-vertices in preparation for the next pass of the Leiden algorithm (which operates on the super-vertex graph). Here, the \texttt{leidenAggregate()} function takes the current graph $G'$ and the community membership $C'$ as input, and returns the super-vertex graph $G''$.

In lines \ref{alg:leidenag--coff-begin}-\ref{alg:leidenag--coff-end}, the offsets array for the community vertices CSR $G'_{C'}.offsets$ is obtained. This is achieved by initially counting the number of vertices in each community using \texttt{countCommunityVert} \texttt{ices()} and subsequently performing an exclusive scan on the array. In lines \ref{alg:leidenag--comv-begin}-\ref{alg:leidenag--comv-end},  a parallel iteration over all vertices is performed to atomically populate vertices belonging to each community into the community graph CSR $G'_{C'}$. Following this, the offsets array for the super-vertex graph CSR is obtained by overestimating the degree of each super-vertex. This involves calculating the total degree of each community with \texttt{communityTotalDegree()} and performing an exclusive scan on the array (lines \ref{alg:leidenag--yoff-begin}-\ref{alg:leidenag--yoff-end}). As a result, the super-vertex graph CSR becomes holey, featuring gaps between the edges and weights arrays of each super-vertex in the CSR.

Then, in lines \ref{alg:leidenag--y-begin}-\ref{alg:leidenag--y-end}, a parallel iteration over all communities $c \in [0, |\Gamma|)$ is performed. For each vertex $i$ belonging to community $c$, all communities $d$ (with associated edge weight $w$), linked to $i$ as defined by \texttt{scanCommunities()} in Algorithm \ref{alg:leidenlm}, are added to the per-thread hashtable $H_t$. Once $H_t$ is populated with all communities (and associated weights) linked to community $c$, these are atomically added as edges to super-vertex $c$ in the super-vertex graph $G''$. Finally, in line \ref{alg:leidenag--return}, we return the super-vertex graph $G''$.
