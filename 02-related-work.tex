The \textit{Louvain} method is a greedy modularity-optimization based community detection algorithm, and is introduced by Blondel et al. from the University of Louvain \cite{com-blondel08}. It identifies communities with resulting high modularity, and is thus widely favored \cite{com-lancichinetti09}. However, it frequently identifies communities that are internally disconnected. A certain vertex that acts as bridge may move to another community. Remaining vertices stay well connected. Iterating the algorithm aggravates the problem. Although its does not decrease quality function \cite{com-traag19}. Further, Louvain algorithm may identify communities that are arbitrarily badly connected. Vertices that are grouped together may be better off split into multiple communities, i.e., splitting the community can improve the quality. This is not the same as resolution limit problem with modularity, that causes small communities to be clustered with large communities. Louvain only guarantees that no communities can be merged (well separated). Badly connected => Leiden could split given communities \cite{com-traag19}. Louvain method relies on modularity score, which has resolution issues (cant handle too small communities, solution CPM score).

Unlike the Louvain algorithm, the Leiden algorithm has an additional refine phase after the local-moving phase, where nodes within each community are local-moved again after reset. Refine phase is randomized (not greedy), the community a node moves to is proportional to the delta-modularity of moving to that community. When nodes are greedily moved, some optimal partitions cannot be found. It uses local-move with pruning (however, we apply this optimizations to both algorithms) \cite{com-traag19}.

The algorithm introduces a \textit{refinement phase} after the local-moving phase, where vertices within each community undergo additional local moves, within their communties obtained from the local-moving phase, in a randomized fashion proportional to the delta-modularity of the move. This non-greedy refinement addresses issues arising from Louvain's greedy approach, allowing vertices to find sub-communities within those obtained from the local-moving phase. The Leiden algorithm not only guarantees that all communities are well separated (like the Louvain method), but also are well connected. In cases where the partition doesn't change, Leiden algorithm ensures that all vertices are optimally assigned, and all communities are subset optimal \cite{com-traag19}.

Shi et al. \cite{com-shi21} also do an additional refinement after clustering with the Louvain method. This minimizes bad clusters, and is similar to refinement phase in Leiden algorithm.

% The idea behind the new leiden algorithm is that louvain can find arbitrarily badly connected communities and even disconnected communities. Louvain algorithm has two phases, a locl-moving phase, and an aggregation phase (for each pass). Leiden algorithm adds another refinement phase between the two, where it allows vertices to find sub-communities within the communities just obtained from local-moving phase.
% They add a refinement step and a better (random) local move approach. The restructuring phase is also with refinement. They also proved is supplementary section why its better.

However, a number of algorithmic improvements proposed for the Louvain method, that also apply to the Leiden algorithm. These include early pruning of non-promising candidates (leaf vertices) \cite{com-ryu16, com-halappanavar17, com-zhang21, com-you22}, attempting local move only on likely vertices \cite{com-ryu16, com-ozaki16, com-zhang21, com-shi21}, ordering of vertices based on node importance \cite{com-aldabobi22}, moving nodes to a random neighbor community \cite{com-traag15}, threshold scaling \cite{com-lu15, com-naim17, com-halappanavar17}, threshold cycling \cite{com-ghosh18}, subnetwork refinement \cite{com-waltman13, com-traag19}, multilevel refinement \cite{com-rotta11, com-gach14, com-shi21}, and early termination \cite{com-ghosh18}.

A number of parallelization strategies have been attempted for the Louvain method. These can also be applied to the Leiden algorithm. These include using heuristics to break the sequential barrier \cite{com-lu15}, ordering vertices via graph coloring \cite{com-halappanavar17}, performing iterations asynchronously \cite{com-que15, com-shi21}, using adaptive parallel thread assignment \cite{com-fazlali17, com-naim17, com-sattar19, com-mohammadi20}, parallelizing the costly first iteration \cite{com-wickramaarachchi14}, using vector based hashtables \cite{com-halappanavar17}, and using sort-reduce instead of hashing \cite{com-cheong13}\ignore{, using simple partitions based of vertex ids \cite{com-cheong13, com-ghosh18}, and identifying and moving ghost/doubtful vertices \cite{com-zeng15, com-que15, com-bhowmik19, com-bhowmick22}}.\ignore{Platforms used range from an AMD multicore system \cite{com-fazlali17}, and Intel’s Knight's Landing, Haswell \cite{com-gheibi20}, SkylakeX, and Cascade Lake \cite{part-hossain21}. Other approaches include the use of MapReduce in a BigData batch processing framework \cite{com-zeitz17}.}It should however be noted though that community detection methods such as the Louvain that rely on modularity maximization are known to suffer from resolution limit problem. This prevents identification of communities of certain sizes \cite{com-ghosh19}.
%% On CPM

A few open source implementations and software packages have been developed for community detection using Leiden algorithm. The original implementation of the Leiden algorithm \cite{com-traag19} that incorporates several heuristics to enhance performance while maintaining solution quality, while Grappolo \cite{com-halappanavar17} is a shared memory parallel implementation. NetworKit \cite{staudt2016networkit} is a software package designed for analyzing the structural aspects of graph data sets with billions of connections. It is implemented as a hybrid with C++ kernels and a Python frontend, and includes parallel implementation of the Leiden algorithm by Nguyen \cite{nguyenleiden}. igraph \cite{csardi2006igraph} is a similar package, written in C, with Python, R, and Mathematica frontends. It is widely used in academic research, and includes implementation of the Leiden algorithm.


%% Related work on Leiden algorithm
I see two thesis by Fabian, Karlsruhe Institute of Technology and Magnus, University of Bergen. Fabian uses global queues and for vertex pruning, and vertex and community locking for updating communities, which is likely to be less efficient. Magnus uses the same approach as Fabien. On europe graph their algorithm takes 60-70s with 64 threads (on a 128 core system).

%% More related work for community detection
I found one paper by Prof. L. Dhulipala "Scalable community detection via Parallel Correlation Clustering". They write about (static) Louvain algorithm using LambdaCC objective (instead of modularity). They explore three optimizations for the Louvain algorithm:
- They find asynchronous (ordered) Louvain performs well (quality and speed due to symmetry breaking).
(I observe the same in experiments too)
- They filter which vertices to consider moving in the next iteration (instead of all).
(This is similar to Dynamic Frontier but applied to static algorithm)
- They do an additional refinement after clustering (this minimizes bad clusters).
(This is similar to refinement phase in Leiden algorithm)




%% Leiden algorithm: Guarantees
% 1. All communities are $\gamma$-separated.
% 2. All communities are $\gamma$-connected.
% If partition didn’t change:
% 3. All nodes are optimally assigned.
% 4. All communities are subpartition $\gamma$-dense.
% 5. All communities are uniformly $\gamma$-dense.
% 6. All communities are subset optimal.
