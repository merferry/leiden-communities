\subsection{Experimental Setup}
\label{sec:setup}

We use a server that has two $16$-core x86-based Intel Xeon Gold 6226R processors running at $2.90$ GHz. Each core has an L1 cache of $1$ MB, an L2 cache of $16$ MB, and a shared L3 cache of $22$ MB. The machine has $93.4$ GB of system memory and runs on CentOS Stream 8. We use GCC 8.5 and OpenMP 4.5. Table \ref{tab:dataset} shows the graphs we use in our experiments. All of them are obtained from the SuiteSparse Matrix Collection \cite{suite19}.


%% Additional setup details for Leiden algorithm (also applies to Louvain)
We use 32-bit integers for vertex ids and 32-bit float for edge weights but use 64-bit floats for computations and hashtable values. We utilize $64$ threads to match the number of cores available on the system. In the graphs, number of vertices vary from $3.07$ to $214$ million, and number of edges vary from $25.4$ million to $3.80$ billion. We ensure edges to be undirected and weighted with a default of $1$.

\input{src/tab-dataset}
\input{src/fig-leiden-compare}




\subsection{Comparing Performance of GVE-Leiden}

We now compare the performance of GVE-Leiden with Vite (Louvain), Grappolo (Louvain), and NetworKit Louvain. For Vite, we convert the graph datasets to Vite's binary graph format, run it on a single node\ignore{(Vite supports distributed community detection)} with threshold cycling/scaling optimization, and measure the reported average total time. For Grappolo, we measure the run it on the same system, and measure the reported total time. For NetworKit, we use a Python script to invoke \texttt{PLM} (Parallel Louvain Method), and measure the total time reported with \texttt{getTiming()}. For each graph, we measure the runtime of each implementation five times, for averaging. We also record the modularity of communities obtained, as reported by each implementation.

Figure \ref{fig:leiden-compare--runtime} shows the runtimes of Vite (Louvain), Grappolo (Louvain), NetworKit Louvain, and GVE-Leiden on each graph in the dataset. Figure \ref{fig:leiden-compare--speedup} shows the speedup of GVE-Leiden with respect to each implementation mentioned above. GVE-Leiden is on average $50\times$, $22\times$, and $20\times$ faster than Vite, Grappolo, and NetworKit respectively. On the \textit{sk-2005} graph, GVE-Leiden finds communities in $6.8$ seconds, and thus achieve a processing rate of $560$ million edges/s. Figure \ref{fig:leiden-compare--modularity} shows the modularity of communities obtained with each implementation. GVE-Leiden on average obtains $3.1\%$ higher modularity than Vite (especially on web graphs), and $0.6\%$ lower modularity than Grappolo and NetworKit (especially on social networks with poor clustering).

\input{src/fig-leiden-splits}
\input{src/fig-leiden-hardness}
\input{src/fig-leiden-ss}




\subsection{Analyzing Performance of GVE-Leiden}

%% Disconnected communities with Leiden algorithm
From the initial results it looks like Leiden algorithm is much less likely than Louvain to return disconnected communities. However, the modularity obtained is generally (interestingly) generally lower than PageRank. Also the randomized version of refinement phase of Leiden (using xorshift32 random engine) somehow seems to obtain lower modularity than greedy version of refinement phase.

The phase-wise and pass-wise split of GVE-Leiden is shown in Figures \ref{fig:leiden-splits--phase} and \ref{fig:leiden-splits--pass} respectively. Figure \ref{fig:leiden-splits--phase} indicates that GVE-Leiden spends most of the runtime in the local-moving phase on \textit{web graphs}, \textit{road networks}, and \textit{protein k-mer graphs}, while it devotes majority of the runtime in the aggregation phase on \textit{social networks}. The pass-wise split (Figure \ref{fig:leiden-splits--pass}) indicates that the first pass dominates runtime on high-degree graphs (\textit{web graphs} and \textit{social networks}), while subsequent passes prevail in execution time on low-degree graphs (\textit{road networks} and \textit{protein k-mer graphs}).

On average, $49\%$ of GVE-Leiden's runtime is spent in the local-moving phase, $35\%$ is spent in the aggregation phase, and $16\%$ is spent in other steps (initialization, renumbering communities, looking up dendrogram, and resetting communities) of the algorithm. Further, $67\%$ of the runtime is spent in the first pass of the algorithm, which is the most expensive pass due to the size of the original graph (later passes work on super-vertex graphs) \cite{com-wickramaarachchi14}.

We also observe that graphs with lower average degree (\textit{road networks} and \textit{protein k-mer graphs}) and graphs with poor community structure (such as \verb|com-LiveJournal| and \verb|com-Orkut|) have a larger $\text{runtime}/|E|$ factor, as shown in Figure \ref{fig:leiden-hardness}.


%% Additional analysis for Leiden algorithm
In this section, we observe the performance of our optimized parallel \textit{Leiden} (\textit{greedy variant}) with respect to \textit{Louvain} (which is optimized and parallelized in a manner similar to \textit{Leiden}). For each graphs in the dataset, we run each algorithm 5 times to minimize measurement noise, and report the average results in Figures \ref{fig:leiden-disconnected}, \ref{fig:leiden-modularity}, and \ref{fig:leiden-time}.

Figure \ref{fig:leiden-disconnected} shows the percentage of disconnected communities obtained with both algorithms for each graph in the dataset. \textit{Leiden} obtains drastically reduced number of disconnected communities compared to \textit{Louvain} (except on road networks), achieving an average of $20\times$ reduction in disconnected communities. Meanwhile, Figure \ref{fig:leiden-modularity} shows the modularity of both algorithms on the same dataset. We observe that \textit{Leiden}, on average, obtains communities of slightly higher modularity than \textit{Louvain}. Lastly, Figure \ref{fig:leiden-time} shows the runtime of both algorithms across the dataset. \textit{Leiden} is on average $26\%$ slower than Louvain. Nonetheless, this increase in computation time is a minor trade-off for obtaining predominantly well-connected high-quality communities.




\subsection{Strong Scaling of GVE-Leiden}

Finally, we measure the strong scaling performance of GVE-Leiden. To this end, we adjust the number of threads from $1$ to $64$ in multiples of $2$ for each input graph, and measure the overall time taken for finding communities with GVE-Leiden, as well as its phase splits (local-moving, aggregation, others), five times for averaging. The results are shown in Figure \ref{fig:leiden-ss}. With 32 threads, GVE-Leiden obtains an average speedup of $10.4\times$ compared to running with a single thread, i.e., its performance increases by $1.6\times$ for every doubling of threads. Scaling is limited due to the various sequential steps/phases in the algorithm. At 64 threads, GVE-Leiden is impacted by NUMA effects, and offers speedup of only $11.4\times$.
