In conclusion, this study addresses the optimization of Leiden method, a high-quality community detection algorithm, in the shared memory setting. We consider 9 different optimizations, which significantly improve the performance of the local-moving and the aggregation phases of the algorithm. On a server with dual 16-core Intel Xeon Gold 6226R processors, comparison with competitive open source implementations (Vite and Grappolo) and packages (NetworKit) show that our optimized implementation of Leiden, which we term as GVE-Leiden, is on average $373\times$, $86\times$, and $7.2\times$ faster than original Leiden, igraph Leiden, and NetworKit Leiden respectively. In addition, GVE-Leiden on average obtains $0.1\%$ lower modularity than the original Leiden and igraph Leiden, and $20\%$ higher modularity than NetworKit Leiden. On a web graph with $3.8$ billion edges, GVE-Leiden identifies communities in $10.8$ seconds, and thus achieves a processing rate of $352$ million edges/s. In addition, GVE-Leiden achieves a strong scaling factor of $1.6\times$ for every doubling of threads. Looking ahead, future work could focus of designing dynamic algorithms for Leiden to accommodate dynamic graphs which evolve over time. This would contribute to interactive updation of community memberships of vertices in real-world scenarios.

%% Additional conclusion for Leiden algorithm
This poster presents an optimized parallel version of the \textit{Leiden} algorithm for community detection. Our implementation can identify communities in a large undirected web graph with $1.9$ billion edges in just $10$ seconds using a single 64-core CPU. When compared to our optimized parallel \textit{Louvain} implementation, \textit{Leiden} achieves a $20$-fold reduction in disconnected communities, slightly higher net modularity, and only a $26\%$ drop in performance. This makes \textit{Leiden} an attractive choice for community detection on massive graphs.
