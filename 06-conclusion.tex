In conclusion, this study addresses the design of the most optimized multicore implementation of the Leiden algorithm \cite{com-traag19}, to the best of our knowledge. Here, we extend optimizations from our implementation of the Louvain algorithm \cite{sahu2023gvelouvain}, and use a greedy refinement phase where vertices greedily optimize for delta-modularity within their community bounds, which we observe, offers both better performance and quality than a randomized approach. On a system equipped with two 16-core Intel Xeon Gold 6226R processors, our implementation of the Leiden algorithm, referred to as GVE-Leiden, attains a processing rate of $403 M$ edges per second on a $3.8 B$ edge graph. It outperforms the original Leiden implementation, igraph Leiden, NetworKit Leiden, and cuGraph Leiden (run on an NVIDIA A100 GPU) by $436\times$, $104\times$, $8.2\times$, and $3.0\times$ respectively. GVE-Leiden identifies communities of equivalent quality to the first two implementations, and $25\%$ / $3.5\%$ higher quality than NetworKit / cuGraph. Doubling the number of threads results in a average performance scaling of $1.6\times$ for GVE-Leiden.

In a previous version of this report, we implemented the refinement phase of the Leiden algorithm utilizing a \textit{constrained move} procedure, which does not guarantee the absence of disconnected communities. In this current version of the report, we have transitioned to employing the \textit{constrained merge} procedure alongside atomics to ensure no internally-disconnected communities. We also addressed issues in measuring disconnected communities for the original Leiden and igraph Leiden, which arose due to the number of vertices in a graph varying between the Matrix Market and the Edgelist formats (which does not have isolated vertices), and used the \texttt{RBConfigurationVertexPartition} with the original Leiden for large graphs (i.e., \textit{webbase-2001} and \textit{sk-2005}).
